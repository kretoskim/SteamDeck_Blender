import bpy
import hid
import struct
import mathutils

# -------------------------------
# Settings
# -------------------------------
ROTATE_STEP = 0.0157079  # ~0.9° per tick (~60°/s at 66.67 ticks/s)

# -------------------------------
# Decode HID data
# -------------------------------
def decode_deck_report(data):
    if len(data) < 16:
        return None

    data_bytes = bytes(data)

    # Buttons
    buttons_triggers = data_bytes[8]
    buttons_dpad = data_bytes[9]
    pressed = []

    if buttons_triggers & 0x01: pressed.append("R2")
    if buttons_triggers & 0x02: pressed.append("L2")
    if buttons_triggers & 0x04: pressed.append("R1")
    if buttons_triggers & 0x08: pressed.append("L1")
    if buttons_triggers & 0x10: pressed.append("Y")
    if buttons_triggers & 0x20: pressed.append("B")
    if buttons_triggers & 0x40: pressed.append("X")
    if buttons_triggers & 0x80: pressed.append("A")
    if buttons_dpad & 0x01: pressed.append("DPad Up")
    if buttons_dpad & 0x02: pressed.append("DPad Right")
    if buttons_dpad & 0x04: pressed.append("DPad Left")
    if buttons_dpad & 0x08: pressed.append("DPad Down")

    return {"buttons": pressed}

# -------------------------------
# Get 3D View context
# -------------------------------
def get_3d_view_context(context):
    for area in context.screen.areas:
        if area.type == 'VIEW_3D':
            for region in area.regions:
                if region.type == 'WINDOW':
                    override = {'area': area, 'region': region, 'space_data': area.spaces.active}
                    return override, area, area.spaces.active.region_3d
    print("Error: No 3D Viewport found")
    return None, None, None

# -------------------------------
# Handle button actions
# -------------------------------
def handle_buttons(decoded, context):
    override, area, rv3d = get_3d_view_context(context)
    if not override or not rv3d:
        return

    buttons = decoded['buttons']
    non_repeat_buttons = [b for b in buttons if b not in {"L1", "R1", "L2", "R2"}]

    # Continuous rotation with L1/R1/L2/R2
    if "L1" in buttons:
        try:
            bpy.ops.view3d.view_orbit(override, angle_x=0, angle_y=ROTATE_STEP)
            print("L1: Rotate left (Numpad 4)")
        except Exception as e:
            print(f"L1 rotation error: {e}")
            quat = mathutils.Quaternion((0, 0, 1), ROTATE_STEP)
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("L1: Rotate left (Numpad 4, fallback)")
    if "R1" in buttons:
        try:
            bpy.ops.view3d.view_orbit(override, angle_x=0, angle_y=-ROTATE_STEP)
            print("R1: Rotate right (Numpad 6)")
        except Exception as e:
            print(f"R1 rotation error: {e}")
            quat = mathutils.Quaternion((0, 0, 1), -ROTATE_STEP)
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("R1: Rotate right (Numpad 6, fallback)")
    if "L2" in buttons:
        try:
            bpy.ops.view3d.view_orbit(override, angle_x=0, angle_y=ROTATE_STEP)
            print("L2: Rotate down (Numpad 2)")
        except Exception as e:
            print(f"L2 rotation error: {e}")
            quat = mathutils.Quaternion((0, 1, 0), ROTATE_STEP)
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("L2: Rotate down (Numpad 2, fallback)")
    if "R2" in buttons:
        try:
            bpy.ops.view3d.view_orbit(override, angle_x=0, angle_y=-ROTATE_STEP)
            print("R2: Rotate up (Numpad 8)")
        except Exception as e:
            print(f"R2 rotation error: {e}")
            quat = mathutils.Quaternion((0, 1, 0), -ROTATE_STEP)
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("R2: Rotate up (Numpad 8, fallback)")

    # Handle non-repeating buttons
    for b in non_repeat_buttons:
        try:
            if b == "A":
                bpy.ops.object.select_all(override, action='SELECT')
                print("A: Select all")
            elif b == "B":
                bpy.ops.object.hide_view_clear(override)
                print("B: Show all")
            elif b == "X":
                bpy.ops.object.delete(override)
                print("X: Delete")
            elif b == "Y":
                bpy.ops.object.duplicate_move(override)
                print("Y: Duplicate")
            elif b == "DPad Up":
                bpy.ops.view3d.view_axis(override, type='TOP')
                print("DPad Up: Top view")
            elif b == "DPad Down":
                bpy.ops.view3d.view_axis(override, type='BOTTOM')
                print("DPad Down: Bottom view")
            elif b == "DPad Left":
                bpy.ops.view3d.view_axis(override, type='LEFT')
                print("DPad Left: Left view")
            elif b == "DPad Right":
                bpy.ops.view3d.view_axis(override, type='RIGHT')
                print("DPad Right: Right view")
        except Exception as e:
            print(f"Button action error ({b}): {e}")

    if area:
        area.tag_redraw()

# -------------------------------
# Modal Operator
# -------------------------------
class SteamDeckOperator(bpy.types.Operator):
    bl_idname = "wm.steam_deck_operator"
    bl_label = "Steam Deck Controller"

    _timer = None
    h = None
    last_buttons = None

    def modal(self, context, event):
        if event.type == 'TIMER':
            try:
                data = self.h.read(64, timeout_ms=200)
                if data:
                    decoded = decode_deck_report(data)
                    if decoded:
                        handle_buttons(decoded, context)
                        # Update last_buttons for non-repeating actions
                        non_repeat_buttons = [b for b in decoded['buttons'] if b not in {"L1", "R1", "L2", "R2"}]
                        self.last_buttons = non_repeat_buttons
            except Exception as e:
                print("Read error:", e)

        if event.type == 'ESC' or not context.window_manager.get('steam_deck_active', True):
            self.cancel(context)
            return {'CANCELLED'}

        return {'PASS_THROUGH'}

    def execute(self, context):
        devices = hid.enumerate(0x28DE, 0x1205)
        if not devices:
            self.report({'ERROR'}, "No Steam Deck devices found")
            return {'CANCELLED'}

        self.h = hid.device()
        for iface in [2, 1]:
            for device in devices:
                if device['interface_number'] == iface:
                    try:
                        self.h.open_path(device['path'])
                        print(f"Connected to interface {iface}")
                        break
                    except Exception as e:
                        print(f"Failed to open interface {iface}: {e}")
            else:
                continue
            break
        else:
            self.report({'ERROR'}, "No suitable interface found")
            return {'CANCELLED'}

        # Disable lizard mode
        for report in [bytes([0x87, 0x00]), bytes([0x81, 0x00]), bytes([0x8e, 0x00])]:
            try:
                self.h.send_feature_report(report)
            except:
                pass

        # Request gamepad report
        try:
            self.h.write_report(0, bytes([0x01, 0x00] + [0] * 62))
        except:
            pass

        self.h.set_nonblocking(True)
        wm = context.window_manager
        wm['steam_deck_active'] = True
        self._timer = wm.event_timer_add(0.015, window=context.window)
        wm.modal_handler_add(self)
        return {'RUNNING_MODAL'}

    def cancel(self, context):
        wm = context.window_manager
        wm['steam_deck_active'] = False
        if self._timer:
            wm.event_timer_remove(self._timer)
        if self.h:
            self.h.close()
        print("Steam Deck controller stopped")

# -------------------------------
# Register
# -------------------------------
def register():
    try:
        bpy.utils.unregister_class(SteamDeckOperator)
        if 'steam_deck_active' in bpy.types.WindowManager.__annotations__:
            del bpy.types.WindowManager.steam_deck_active
    except:
        pass
    bpy.utils.register_class(SteamDeckOperator)
    bpy.types.WindowManager.steam_deck_active = bpy.props.BoolProperty(default=False)

def unregister():
    try:
        bpy.utils.unregister_class(SteamDeckOperator)
        if 'steam_deck_active' in bpy.types.WindowManager.__annotations__:
            del bpy.types.WindowManager.steam_deck_active
    except:
        pass

if __name__ == "__main__":
    register()