import bpy
import hid
import struct
import mathutils

# -------------------------------
# Settings
# -------------------------------
ROTATE_STEP = 0.0157079  # ~0.9° per tick (~60°/s at 66.67 ticks/s)
ZOOM_FACTOR = 0.05  # ~5% change in view_distance per press

# -------------------------------
# Decode HID data
# -------------------------------
def decode_deck_report(data):
    if len(data) < 16:
        return None

    data_bytes = bytes(data)

    # Buttons
    buttons_triggers = data_bytes[8]
    buttons_dpad = data_bytes[9]
    pressed = []

    if buttons_triggers & 0x01: pressed.append("R2")
    if buttons_triggers & 0x02: pressed.append("L2")
    if buttons_triggers & 0x04: pressed.append("R1")
    if buttons_triggers & 0x08: pressed.append("L1")
    if buttons_triggers & 0x10: pressed.append("Y")
    if buttons_triggers & 0x20: pressed.append("B")
    if buttons_triggers & 0x40: pressed.append("X")
    if buttons_triggers & 0x80: pressed.append("A")
    if buttons_dpad & 0x01: pressed.append("DPad Up")
    if buttons_dpad & 0x02: pressed.append("DPad Right")
    if buttons_dpad & 0x04: pressed.append("DPad Left")
    if buttons_dpad & 0x08: pressed.append("DPad Down")

    return {"buttons": pressed}

# -------------------------------
# Get 3D View context
# -------------------------------
def get_3d_view_context(context):
    for area in context.screen.areas:
        if area.type == 'VIEW_3D':
            for region in area.regions:
                if region.type == 'WINDOW':
                    override = {'area': area, 'region': region, 'space_data': area.spaces.active}
                    return override, area, area.spaces.active.region_3d
    print("Error: No 3D Viewport found")
    return None, None, None

# -------------------------------
# Get Timeline/Dope Sheet context
# -------------------------------
def get_timeline_context(context):
    for area in context.screen.areas:
        if area.type in {'TIMELINE', 'DOPESHEET_EDITOR'}:
            for region in area.regions:
                if region.type == 'WINDOW':
                    override = {'area': area, 'region': region, 'space_data': area.spaces.active}
                    return override, area
    print("Error: No Timeline or Dope Sheet found")
    return None, None

# -------------------------------
# Handle button actions
# -------------------------------
def handle_buttons(decoded, context):
    # Get 3D View context for viewport actions
    view_override, view_area, rv3d = get_3d_view_context(context)
    # Get Timeline/Dope Sheet context for timeline actions
    timeline_override, timeline_area = get_timeline_context(context)

    buttons = decoded['buttons']
    non_repeat_buttons = [b for b in buttons if b not in {"L1", "R1", "L2", "R2"}]

    # Continuous rotation with L1/R1/L2/R2 (3D Viewport)
    if view_area and rv3d:
        if "L1" in buttons:
            quat = mathutils.Quaternion((0, 0, 1), ROTATE_STEP)  # global Z
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("L1: Rotate left (global Z)")
        if "R1" in buttons:
            quat = mathutils.Quaternion((0, 0, 1), -ROTATE_STEP)  # global Z
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("R1: Rotate right (global Z)")
        if "L2" in buttons:
            quat = mathutils.Quaternion((1, 0, 0), ROTATE_STEP)  # global X
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("L2: Rotate up (global X)")
        if "R2" in buttons:
            quat = mathutils.Quaternion((1, 0, 0), -ROTATE_STEP)  # global X
            rv3d.view_rotation = quat @ rv3d.view_rotation
            print("R2: Rotate down (global X)")

    # Handle non-repeating buttons
    for b in non_repeat_buttons:
        try:
            if b == "A" and view_override and view_area:
                try:
                    bpy.ops.view3d.zoom(view_override, delta=0.5)
                    print("A: Zoom in (Numpad +)")
                except Exception as e:
                    print(f"A zoom error: {e}")
                    if rv3d:
                        rv3d.view_distance *= (1 - ZOOM_FACTOR)  # Decrease distance (~5%)
                        print("A: Zoom in (Numpad +, fallback)")
            elif b == "Y" and view_override and view_area:
                try:
                    bpy.ops.view3d.zoom(view_override, delta=-0.5)
                    print("Y: Zoom out (Numpad -)")
                except Exception as e:
                    print(f"Y zoom error: {e}")
                    if rv3d:
                        rv3d.view_distance *= (1 + ZOOM_FACTOR)  # Increase distance (~5%)
                        print("Y: Zoom out (Numpad -, fallback)")
            elif b == "B" and view_override and view_area:
                bpy.ops.object.hide_view_clear(view_override)
                print("B: Show all")
            elif b == "X" and view_override and view_area:
                bpy.ops.object.delete(view_override)
                print("X: Delete")
            elif b == "DPad Up":
                try:
                    if timeline_override and timeline_area:
                        bpy.ops.screen.frame_offset(timeline_override, delta=1)
                        print("DPad Up: Right arrow key (scrub timeline forward)")
                    else:
                        bpy.context.scene.frame_current += 1
                        print("DPad Up: Right arrow key (scrub timeline forward, no timeline context)")
                except Exception as e:
                    print(f"DPad Up error: {e}")
                    bpy.context.scene.frame_current += 1
                    print("DPad Up: Right arrow key (scrub timeline forward, fallback)")
            elif b == "DPad Down" and view_override and view_area:
                bpy.ops.view3d.view_axis(view_override, type='BOTTOM')
                print("DPad Down: Bottom view")
            elif b == "DPad Left" and view_override and view_area:
                bpy.ops.view3d.view_axis(view_override, type='LEFT')
                print("DPad Left: Left view")
            elif b == "DPad Right" and view_override and view_area:
                bpy.ops.view3d.view_axis(view_override, type='RIGHT')
                print("DPad Right: Right view")
        except Exception as e:
            print(f"Button action error ({b}): {e}")

    if view_area:
        view_area.tag_redraw()
    if timeline_area:
        timeline_area.tag_redraw()

# -------------------------------
# Modal Operator
# -------------------------------
class SteamDeckOperator(bpy.types.Operator):
    bl_idname = "wm.steam_deck_operator"
    bl_label = "Steam Deck Controller"

    _timer = None
    h = None
    last_buttons = None

    def modal(self, context, event):
        if event.type == 'TIMER':
            try:
                data = self.h.read(64, timeout_ms=200)
                if data:
                    decoded = decode_deck_report(data)
                    if decoded:
                        handle_buttons(decoded, context)
                        # Update last_buttons for non-repeating actions
                        non_repeat_buttons = [b for b in decoded['buttons'] if b not in {"L1", "R1", "L2", "R2"}]
                        self.last_buttons = non_repeat_buttons
            except Exception as e:
                print("Read error:", e)

        if event.type == 'ESC' or not context.window_manager.get('steam_deck_active', True):
            self.cancel(context)
            return {'CANCELLED'}

        return {'PASS_THROUGH'}

    def execute(self, context):
        devices = hid.enumerate(0x28DE, 0x1205)
        if not devices:
            self.report({'ERROR'}, "No Steam Deck devices found")
            return {'CANCELLED'}

        self.h = hid.device()
        for iface in [2, 1]:
            for device in devices:
                if device['interface_number'] == iface:
                    try:
                        self.h.open_path(device['path'])
                        print(f"Connected to interface {iface}")
                        break
                    except Exception as e:
                        print(f"Failed to open interface {iface}: {e}")
            else:
                continue
            break
        else:
            self.report({'ERROR'}, "No suitable interface found")
            return {'CANCELLED'}

        # Disable lizard mode
        for report in [bytes([0x87, 0x00]), bytes([0x81, 0x00]), bytes([0x8e, 0x00])]:
            try:
                self.h.send_feature_report(report)
            except:
                pass

        # Request gamepad report
        try:
            self.h.write_report(0, bytes([0x01, 0x00] + [0] * 62))
        except:
            pass

        self.h.set_nonblocking(True)
        wm = context.window_manager
        wm['steam_deck_active'] = True
        self._timer = wm.event_timer_add(0.015, window=context.window)
        wm.modal_handler_add(self)
        return {'RUNNING_MODAL'}

    def cancel(self, context):
        wm = context.window_manager
        wm['steam_deck_active'] = False
        if self._timer:
            wm.event_timer_remove(self._timer)
        if self.h:
            self.h.close()
        print("Steam Deck controller stopped")

# -------------------------------
# Register
# -------------------------------
def register():
    try:
        bpy.utils.unregister_class(SteamDeckOperator)
        if 'steam_deck_active' in bpy.types.WindowManager.__annotations__:
            del bpy.types.WindowManager.steam_deck_active
    except:
        pass
    bpy.utils.register_class(SteamDeckOperator)
    bpy.types.WindowManager.steam_deck_active = bpy.props.BoolProperty(default=False)

def unregister():
    try:
        bpy.utils.unregister_class(SteamDeckOperator)
        if 'steam_deck_active' in bpy.types.WindowManager.__annotations__:
            del bpy.types.WindowManager.steam_deck_active
    except:
        pass

if __name__ == "__main__":
    register()